"use strict";(self.webpackChunkinterview=self.webpackChunkinterview||[]).push([[6072],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>g});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),h=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=h(e.components);return r.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=h(t),g=i,u=c["".concat(l,".").concat(g)]||c[g]||m[g]||a;return t?r.createElement(u,s(s({ref:n},d),{},{components:t})):r.createElement(u,s({ref:n},d))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,s=new Array(a);s[0]=c;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var h=2;h<a;h++)s[h]=t[h];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9506:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var r=t(7462),i=(t(7294),t(3905));const a={tree_title:"Search Algorithms",description:"This will cover the most of the topics that will be part of the Search Algorithms.",last_modified:new Date("2022-06-08T16:53:14.531Z")},s="Search Algorithms",o={unversionedId:"data-structures/search-algorithms",id:"data-structures/search-algorithms",title:"Search Algorithms",description:"This will cover the most of the topics that will be part of the Search Algorithms.",source:"@site/docs/data-structures/search-algorithms.md",sourceDirName:"data-structures",slug:"/data-structures/search-algorithms",permalink:"/interview/docs/data-structures/search-algorithms",draft:!1,tags:[],version:"current",frontMatter:{tree_title:"Search Algorithms",description:"This will cover the most of the topics that will be part of the Search Algorithms.",last_modified:"2022-06-08T16:53:14.531Z"},sidebar:"docs",previous:{title:"Priority Queue",permalink:"/interview/docs/data-structures/priority-queue"},next:{title:"Set",permalink:"/interview/docs/data-structures/set"}},l={},h=[{value:"Binary Search",id:"binary-search",level:2},{value:"Contains (True or False)",id:"contains-true-or-false",level:3},{value:"Index of first occurrence of a key",id:"index-of-first-occurrence-of-a-key",level:3},{value:"Index of last occurrence of a key",id:"index-of-last-occurrence-of-a-key",level:3},{value:"Index of greatest element less than key",id:"index-of-greatest-element-less-than-key",level:3},{value:"Index of least element greater than key",id:"index-of-least-element-greater-than-key",level:3},{value:"Index of target element in Sorted Rotated Array",id:"index-of-target-element-in-sorted-rotated-array",level:3}],d={toc:h};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"search-algorithms"},"Search Algorithms"),(0,i.kt)("h2",{id:"binary-search"},"Binary Search"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Binary Search")," is a ",(0,i.kt)("strong",{parentName:"p"},"searching algorithm")," used in a ",(0,i.kt)("strong",{parentName:"p"},"sorted array")," by repeatedly dividing the search interval in half.\nThe idea of binary search is to use the information that the array is sorted and reduce the time complexity to ",(0,i.kt)("inlineCode",{parentName:"p"},"O(log n)"),"."),(0,i.kt)("h3",{id:"contains-true-or-false"},"Contains (True or False)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n\n    int contains(int low, int high, int target) {\n    int ans = 0;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int midVal = a[mid];\n\n        if (midVal < target) {\n        // If mid is less than target, all elements\n        // in range [low, mid] are also less\n        // so we now search in [mid + 1, high]\n        low = mid + 1;\n        } else if (midVal > target) {\n        // If mid is greater than target, all elements\n        // in range [mid + 1, high] are also greater\n        // so we now search in [low, mid - 1]\n        high = mid - 1;\n        } else if (midVal == target) {\n        // Comparison added just for the sake\n        // of clarity if mid is equal to target, we\n        // have found that target exists in array\n        ans = 1;\n        break;\n        }\n    }\n    return ans;\n    }\n}\n\n// Input : 2 3 3 5 5 5 6 6\n// Function : Contains(4)\n// Returns : False\n\n// Function : Contains(5)\n// Returns : True\n")),(0,i.kt)("h3",{id:"index-of-first-occurrence-of-a-key"},"Index of first occurrence of a key"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n\n    int first(int low, int high, int target) {\n    int ans = -1;\n    while (low <= high) {\n        int mid = low + (high - low + 1) / 2;\n        int midVal = a[mid];\n\n        if (midVal < target) {\n        // If mid is less than target, all elements\n        // in range [low, mid] are also less\n        // so we now search in [mid + 1, high]\n        low = mid + 1;\n        } else if (midVal > target) {\n        // If mid is greater than target, all elements\n        // in range [mid + 1, high] are also greater\n        // so we now search in [low, mid - 1]\n        high = mid - 1;\n        } else if (midVal == target) {\n        // If mid is equal to target, we note down\n        //  the last found index then we search\n        // for more in left side of mid\n        // so we now search in [low, mid - 1]\n        ans = mid;\n        high = mid - 1;\n        }\n    }\n    return ans;\n    }\n}\n\n// Input : 2 3 3 5 5 5 6 6\n// Function : first(3)\n// Returns : 1\n\n// Function : first(5)\n// Returns : 3\n\n// Function : first(4)\n// Returns : -1\n")),(0,i.kt)("h3",{id:"index-of-last-occurrence-of-a-key"},"Index of last occurrence of a key"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n\n    int last(int low, int high, int target) {\n    int ans = -1;\n    while (low <= high) {\n        int mid = low + (high - low + 1) / 2;\n        int midVal = a[mid];\n\n        if (midVal < target) {\n        // If mid is less than target, then all elements\n        // in range [low, mid - 1] are also less\n        // so we now search in [mid + 1, high]\n        low = mid + 1;\n        } else if (midVal > target) {\n        // If mid is greater than target, then all\n        // elements in range [mid + 1, high] are\n        // also greater so we now search in\n        // [low, mid - 1]\n        high = mid - 1;\n        } else if (midVal == target) {\n        // If mid is equal to target, we note down\n        // the last found index then we search\n        // for more in right side of mid\n        // so we now search in [mid + 1, high]\n        ans = mid;\n        low = mid + 1;\n        }\n    }\n    return ans;\n    }\n}\n\n// Input : 2 3 3 5 5 5 6 6\n// Function : last(3)\n// Returns : 2\n\n// Function : last(5)\n// Returns : 5\n\n// Function : last(4)\n// Returns : -1\n")),(0,i.kt)("h3",{id:"index-of-greatest-element-less-than-key"},"Index of greatest element less than key"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n\n    int leastgreater(int low, int high, int target) {\n    int ans = -1;\n\n    while (low <= high) {\n        int mid = low + (high - low + 1) / 2;\n        int midVal = a[mid];\n        if (midVal < target) {\n        // If mid is less than target, all elements\n        // in range [low, mid - 1] are <= target\n        // then we search in right side of mid\n        // so we now search in [mid + 1, high]\n        low = mid + 1;\n        } else if (midVal > target) {\n        // If mid is greater than target, all elements\n        // in range [mid + 1, high] are >= target\n        // we note down the last found index, then\n        // we search in left side of mid\n        // so we now search in [low, mid - 1]\n        ans = mid;\n        high = mid - 1;\n        } else if (midVal == target) {\n        // If mid is equal to target, all elements in\n        // range [low, mid] are <= target\n        // so we now search in [mid + 1, high]\n        low = mid + 1;\n        }\n    }\n    return ans;\n    }\n}\n\n// Input : 2 3 3 5 5 5 6 6\n// Function : leastGreater(2)\n// Returns : 1\n\n// Function : leastGreater(5)\n// Returns : 6\n")),(0,i.kt)("h3",{id:"index-of-least-element-greater-than-key"},"Index of least element greater than key"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n\n    int greatestlesser(int low, int high, int target) {\n    int ans = -1;\n\n    while (low <= high) {\n        int mid = low + (high - low + 1) / 2;\n        int midVal = a[mid];\n\n        if (midVal < target) {\n        // If mid is less than target, all elements\n        // in range [low, mid - 1] are < target\n        // we note down the last found index, then\n        // we search in right side of mid\n        // so we now search in [mid + 1, high]\n        ans = mid;\n        low = mid + 1;\n        } else if (midVal > target) {\n        // If mid is greater than target, all elements\n        // in range [mid + 1, high] are > target\n        // then we search in left side of mid\n        // so we now search in [low, mid - 1]\n        high = mid - 1;\n        } else if (midVal == target) {\n        // If mid is equal to target, all elements\n        // in range [mid + 1, high] are >= target\n        // then we search in left side of mid\n        // so we now search in [low, mid - 1]\n        high = mid - 1;\n        }\n    }\n\n    return ans;\n    }\n}\n\n// Input : 2 3 3 5 5 5 6 6\n// Function : greatestLesser(2)\n// Returns : -1\n\n// Function : greatestLesser(5)\n// Returns : 2\n")),(0,i.kt)("h3",{id:"index-of-target-element-in-sorted-rotated-array"},"Index of target element in Sorted Rotated Array"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public int search(int[] A, int target) {\n    int low = 0;\n    int high = A.length - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (A[mid] == target) return mid;\n\n        if (A[low] <= A[mid]) {\n        if (target >= A[low] && target < A[mid]) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n        } else {\n        if (target > A[mid] && target <= A[high]) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n        }\n    }\n    return A[low] == target ? low : -1;\n    }\n}\n\n// Input : A = [4,5,6,7,0,1,2], target = 0\n// Returns : -1\n")))}m.isMDXComponent=!0}}]);