"use strict";(self.webpackChunkinterview=self.webpackChunkinterview||[]).push([[5582],{8812:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var t=s(7462),i=(s(7294),s(7373));const r={tree_title:"Leetcode-Medium \ud83d\udea7",description:"This will cover up all the medium questions that are available on Leetcode.",last_modified:new Date("2022-06-10T00:17:44.174Z")},a="Leetcode-Medium \ud83d\udea7",l={unversionedId:"questions/leetcode-medium",id:"questions/leetcode-medium",title:"Leetcode-Medium \ud83d\udea7",description:"This will cover up all the medium questions that are available on Leetcode.",source:"@site/docs/questions/leetcode-medium.md",sourceDirName:"questions",slug:"/questions/leetcode-medium",permalink:"/interview/docs/questions/leetcode-medium",draft:!1,tags:[],version:"current",frontMatter:{tree_title:"Leetcode-Medium \ud83d\udea7",description:"This will cover up all the medium questions that are available on Leetcode.",last_modified:"2022-06-10T00:17:44.174Z"},sidebar:"docs",previous:{title:"GeeksforGeeks-Microsoft",permalink:"/interview/docs/questions/geeksforgeeks-microsoft"},next:{title:"Leetcode Data Structure \ud83d\udea7",permalink:"/interview/docs/questions/studyplan-datastructure"}},u={},o=[{value:"Add Two Numbers",id:"add-two-numbers",level:2},{value:"Inputs",id:"inputs",level:3},{value:"Process",id:"process",level:3},{value:"Edge Cases",id:"edge-cases",level:3},{value:"Longest Substring Without Repeating Characters",id:"longest-substring-without-repeating-characters",level:2},{value:"Inputs",id:"inputs-1",level:3},{value:"Process",id:"process-1",level:3},{value:"Edge Cases",id:"edge-cases-1",level:3},{value:"Unique Binary Search Trees",id:"unique-binary-search-trees",level:2},{value:"Inputs",id:"inputs-2",level:4},{value:"Sub problems",id:"sub-problems",level:3},{value:"Edge Cases",id:"edge-cases-2",level:3},{value:"Further Readings",id:"further-readings",level:3},{value:"Problems based on Catalan Number",id:"problems-based-on-catalan-number",level:3},{value:"Solution",id:"solution",level:3},{value:"Binary Tree Level Order Traversal II",id:"binary-tree-level-order-traversal-ii",level:2},{value:"Inputs",id:"inputs-3",level:3},{value:"Sub-problems",id:"sub-problems-1",level:3},{value:"Edge Cases",id:"edge-cases-3",level:3},{value:"Further Readings",id:"further-readings-1",level:3},{value:"Solutions",id:"solutions",level:3},{value:"Solution using Queue (DFS)",id:"solution-using-queue-dfs",level:4},{value:"Solution using DFS (Recursion)",id:"solution-using-dfs-recursion",level:4},{value:"Convert Sorted List to Binary Search Tree",id:"convert-sorted-list-to-binary-search-tree",level:2},{value:"Inputs",id:"inputs-4",level:3},{value:"Sub-problems",id:"sub-problems-2",level:3},{value:"Edge Cases",id:"edge-cases-4",level:3},{value:"Snippets",id:"snippets",level:3},{value:"Finding Middle node of LinkedList",id:"finding-middle-node-of-linkedlist",level:4},{value:"Further Readings",id:"further-readings-2",level:3},{value:"Solution",id:"solution-1",level:3},{value:"Path Sum II",id:"path-sum-ii",level:2},{value:"Inputs",id:"inputs-5",level:3},{value:"Sub-problems",id:"sub-problems-3",level:3},{value:"Edge Cases",id:"edge-cases-5",level:3},{value:"Further Readings",id:"further-readings-3",level:3},{value:"Solution",id:"solution-2",level:3},{value:"Solution using Recursion",id:"solution-using-recursion",level:4},{value:"Find K Pairs with Smallest Sums",id:"find-k-pairs-with-smallest-sums",level:2},{value:"Inputs",id:"inputs-6",level:3},{value:"Sub-problems",id:"sub-problems-4",level:3},{value:"Edge Cases / Clarifications",id:"edge-cases--clarifications",level:3},{value:"Further Readings",id:"further-readings-4",level:3},{value:"Solution",id:"solution-3",level:3},{value:"Lexicographical Numbers",id:"lexicographical-numbers",level:2},{value:"Inputs",id:"inputs-7",level:3},{value:"Sub-problems",id:"sub-problems-5",level:3},{value:"Edge Cases",id:"edge-cases-6",level:3},{value:"Further Readings",id:"further-readings-5",level:3},{value:"Solution",id:"solution-4",level:3},{value:"Using DFS",id:"using-dfs",level:4},{value:"Using Sort on List",id:"using-sort-on-list",level:4},{value:"Using Stack",id:"using-stack",level:4},{value:"Rotate Function",id:"rotate-function",level:2},{value:"Inputs",id:"inputs-8",level:3},{value:"Sub-problems",id:"sub-problems-6",level:3},{value:"Edge Cases",id:"edge-cases-7",level:3},{value:"Further Readings",id:"further-readings-6",level:3},{value:"Valid Square",id:"valid-square",level:2},{value:"Inputs",id:"inputs-9",level:3},{value:"Sub-problems",id:"sub-problems-7",level:3},{value:"Properties of a Square",id:"properties-of-a-square",level:4},{value:"Edge Cases",id:"edge-cases-8",level:3},{value:"Solution",id:"solution-5",level:3},{value:"Checkpoints",id:"checkpoints",level:4}],d={toc:o};function m(e){let{components:n,...s}=e;return(0,i.mdx)("wrapper",(0,t.Z)({},d,s,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"leetcode-medium-"},"Leetcode-Medium \ud83d\udea7"),(0,i.mdx)("h2",{id:"add-two-numbers"},"Add Two Numbers"),(0,i.mdx)("span",{class:"tag-is-success"},"Linked List"),(0,i.mdx)("span",{class:"tag-is-success"},"Math"),(0,i.mdx)("span",{class:"tag-is-success"},"Recursion"),(0,i.mdx)("h3",{id:"inputs"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n")),(0,i.mdx)("h3",{id:"process"},"Process"),(0,i.mdx)("h3",{id:"edge-cases"},"Edge Cases"),(0,i.mdx)("h2",{id:"longest-substring-without-repeating-characters"},"Longest Substring Without Repeating Characters"),(0,i.mdx)("span",{class:"tag-is-success"},"Hash Table"),(0,i.mdx)("span",{class:"tag-is-success"},"String"),(0,i.mdx)("span",{class:"tag-is-success"},"Sliding Window"),(0,i.mdx)("h3",{id:"inputs-1"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'Input: s = "abcabcbb"\nOutput: 3\nExplanation: The answer is "abc", with the length of 3.\n\nInput: s = "bbbbb"\nOutput: 1\nExplanation: The answer is "b", with the length of 1.\n\nInput: s = "pwwkew"\nOutput: 3\nExplanation: The answer is "wke", with the length of 3.\nNotice that the answer must be a substring, "pwke" is a subsequence and not a substring.\n')),(0,i.mdx)("h3",{id:"process-1"},"Process"),(0,i.mdx)("h3",{id:"edge-cases-1"},"Edge Cases"),(0,i.mdx)("h2",{id:"unique-binary-search-trees"},"Unique Binary Search Trees"),(0,i.mdx)("span",{class:"tag-is-success"},"Math"),(0,i.mdx)("span",{class:"tag-is-success"},"Dynamic Programming"),(0,i.mdx)("span",{class:"tag-is-success"},"Tree"),(0,i.mdx)("span",{class:"tag-is-success"},"Binary Search Tree"),(0,i.mdx)("span",{class:"tag-is-success"},"Binary Tree"),(0,i.mdx)("h4",{id:"inputs-2"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public int numTrees(int n) {\n        \n    }\n}\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Input: 3\nOutput: 5\nExplanation:\nGiven n = 3, there are a total of 5 unique BST's:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\nInput: n = 1\nOutput: 1\n")),(0,i.mdx)("h3",{id:"sub-problems"},"Sub problems"),(0,i.mdx)("p",null,"\u2705 Whether we can apply the DP here, can this be broken into further sub-problems.",(0,i.mdx)("br",null),"\n\u2705 Can there be possibility that current result is based on the previous results.",(0,i.mdx)("br",null),"\n\u2705 How many different combination can be formed using 1 Node, 2 Node, 3 Node, ..., n Node.",(0,i.mdx)("br",null),"\n\u2705 Can you arrive any equation to solve the problem, based upon the previous points.",(0,i.mdx)("br",null)),(0,i.mdx)("h3",{id:"edge-cases-2"},"Edge Cases"),(0,i.mdx)("h3",{id:"further-readings"},"Further Readings"),(0,i.mdx)("p",null,"\u2705 What is the Catalan Number?",(0,i.mdx)("br",null),"\nThe Catalan numbers are a sequence of natural numbers that occur in various counting problems,\noften involving recursively defined objects."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"C(n,k) = (n!) / [(n-k)! * k!] = [ n(n-1)(n-2)(n-3)....1 ] / [ (n-k)! * k! ]\n\nNow (n-k)! factor get cancelled from Numerator and Denominator , and we got\nC(n, k) = [ n(n-1)...( n-(k+1) ) ] / [ k*(k-1)*(k-2)....1 ].\n        = [ (n-1)/1 ] * [ ( n-2)/2 ] * [ (n-3) / 3 ].....[ (n - (k+1)) / k ]\n\nThe first Catalan numbers for n = 0, 1, 2, 3, ... are 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, ... \n")),(0,i.mdx)("h3",{id:"problems-based-on-catalan-number"},"Problems based on Catalan Number"),(0,i.mdx)("p",null,"\u2705Count the number of expressions containing n pairs of parentheses which are correctly matched. For n = 3, possible expressions are ((())), ()(()), ()()(), (())(), (()()).",(0,i.mdx)("br",null),"\n\u2705Count the number of possible Binary Search Trees with n keys.",(0,i.mdx)("br",null),"\n\u2705Count the number of full binary trees (A rooted binary tree is full if every vertex has either two children or no children) with n+1 leaves.",(0,i.mdx)("br",null),"\n\u2705Given a number n, return the number of ways you can draw n chords in a circle with 2 x n points such that no 2 chords intersect.",(0,i.mdx)("br",null)),(0,i.mdx)("h3",{id:"solution"},"Solution"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public int numTrees(int n) {\n        long ans = 1;\n        int k = n;\n        n = 2*n;\n        \n        for(int i = 0  ; i < k ;i++){\n            ans *=  (n-i);\n            ans /=  (i+1);\n        }\n        return (int)(ans/(k+1));       \n    }\n}\n")),(0,i.mdx)("h2",{id:"binary-tree-level-order-traversal-ii"},"Binary Tree Level Order Traversal II"),(0,i.mdx)("span",{class:"tag-is-success"},"Tree"),(0,i.mdx)("span",{class:"tag-is-success"},"Breadth-First Search"),(0,i.mdx)("span",{class:"tag-is-success"},"Binary Tree"),(0,i.mdx)("h3",{id:"inputs-3"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        \n    }\n}\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]\n\nInput: root = [1]\nOutput: [[1]]\n\nInput: root = []\nOutput: []\n")),(0,i.mdx)("h3",{id:"sub-problems-1"},"Sub-problems"),(0,i.mdx)("p",null,"\u2705 Will Recursion be a better solution? What is the complexity.",(0,i.mdx)("br",null),"\n\u2705 If using Recursion, what will the helper method look like.",(0,i.mdx)("br",null),"\n\u2705 Can you think of using Queue with some ArrayList to store the current level nodes.",(0,i.mdx)("br",null)),(0,i.mdx)("h3",{id:"edge-cases-3"},"Edge Cases"),(0,i.mdx)("p",null,"\u2705 Check for the root being null.",(0,i.mdx)("br",null),"\n\u2705 Check if the root is the only node in the tree.",(0,i.mdx)("br",null)),(0,i.mdx)("h3",{id:"further-readings-1"},"Further Readings"),(0,i.mdx)("h3",{id:"solutions"},"Solutions"),(0,i.mdx)("h4",{id:"solution-using-queue-dfs"},"Solution using Queue (DFS)"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                if(node.left != null) queue.add(node.left);\n                if(node.right != null) queue.add(node.right);\n            }\n            result.add(0, level);\n        }\n        return result;\n    }\n}\n")),(0,i.mdx)("h4",{id:"solution-using-dfs-recursion"},"Solution using DFS (Recursion)"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution {\n\n  public List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> wrapList = new LinkedList<List<Integer>>();\n    levelMaker(wrapList, root, 0);\n    return wrapList;\n  }\n\n  public void levelMaker(List<List<Integer>> list, TreeNode root, int level) {\n    if (root == null) return;\n    if (level >= list.size()) {\n      list.add(0, new LinkedList<Integer>());\n    }\n    levelMaker(list, root.left, level + 1);\n    levelMaker(list, root.right, level + 1);\n    list.get(list.size() - level - 1).add(root.val);\n  }\n}\n")),(0,i.mdx)("h2",{id:"convert-sorted-list-to-binary-search-tree"},"Convert Sorted List to Binary Search Tree"),(0,i.mdx)("span",{class:"tag-is-success"},"Linked List"),(0,i.mdx)("span",{class:"tag-is-success"},"Divide and Conquer"),(0,i.mdx)("span",{class:"tag-is-success"},"Tree"),(0,i.mdx)("span",{class:"tag-is-success"},"Binary Search Tree"),(0,i.mdx)("span",{class:"tag-is-success"},"Binary Tree"),(0,i.mdx)("h3",{id:"inputs-4"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        \n    }\n}\n")),(0,i.mdx)("h3",{id:"sub-problems-2"},"Sub-problems"),(0,i.mdx)("p",null,"\u2705 Can you apply the divide and conquer here?",(0,i.mdx)("br",null),"\n\u2705 Can you find out the middle node in the linked list?",(0,i.mdx)("br",null),"\n\u2705 The middle node will be treated as the Root of the BST.",(0,i.mdx)("br",null),"\n\u2705 Can you find out the left and right sub-tree?",(0,i.mdx)("br",null)),(0,i.mdx)("h3",{id:"edge-cases-4"},"Edge Cases"),(0,i.mdx)("p",null,"\u2705 What if the List is empty?",(0,i.mdx)("br",null),"\n\u2705 What if the List has only one node?",(0,i.mdx)("br",null)),(0,i.mdx)("h3",{id:"snippets"},"Snippets"),(0,i.mdx)("h4",{id:"finding-middle-node-of-linkedlist"},"Finding Middle node of LinkedList"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public ListNode middleNode(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n}\n")),(0,i.mdx)("h3",{id:"further-readings-2"},"Further Readings"),(0,i.mdx)("h3",{id:"solution-1"},"Solution"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return listToBST(head, null);\n    }\n    private TreeNode listToBST(ListNode head, ListNode tail) {\n        if (head == null || head == tail) return null;\n        ListNode mid = findMid(head, tail);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = listToBST(head, mid);\n        root.right = listToBST(mid.next, tail);\n        return root;\n    }\n    private ListNode findMid(ListNode head, ListNode tail) {\n        ListNode l1 = head, l2 = head;\n        while (l2 != tail && l2.next != tail) {\n            l1 = l1.next;\n            l2 = l2.next.next;\n        }\n        return l1;\n    }\n}\n")),(0,i.mdx)("h2",{id:"path-sum-ii"},"Path Sum II"),(0,i.mdx)("p",null,"Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. ",(0,i.mdx)("br",null),"Each path should be returned as a list of the node values, not node references.",(0,i.mdx)("br",null),"\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.",(0,i.mdx)("br",null)),(0,i.mdx)("span",{class:"tag-is-success"},"Backtracking"),(0,i.mdx)("span",{class:"tag-is-success"},"Tree"),(0,i.mdx)("span",{class:"tag-is-success"},"Depth-First Search"),(0,i.mdx)("span",{class:"tag-is-success"},"Binary Tree"),(0,i.mdx)("h3",{id:"inputs-5"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        \n    }\n}\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n\nInput: root = [1,2,3], targetSum = 5\nOutput: []\n\nInput: root = [1,2], targetSum = 0\nOutput: []\n")),(0,i.mdx)("h3",{id:"sub-problems-3"},"Sub-problems"),(0,i.mdx)("p",null,"\u2705 Think about using Recursion. ","[",(0,i.mdx)("em",{parentName:"p"},"Once you have figured it out using the Recursion, think about the parameters of the helper method that you will be using."),"]",(0,i.mdx)("br",null),"\n\u2705 Moving from top - bottom with sub-tree root's value will be target minus the current root value.",(0,i.mdx)("br",null),"\n\u2705 Once the targetSum or the RemainingSum is zero, you can hault the condtion. But is this all the cases that you need to check?",(0,i.mdx)("br",null)),(0,i.mdx)("h3",{id:"edge-cases-5"},"Edge Cases"),(0,i.mdx)("p",null,"\u2705 Check whether all the node's value are negative or positive.",(0,i.mdx)("br",null),"\n\u2705 Check whether the root is null.",(0,i.mdx)("br",null),"\n\u2705 If there is constraint like all the node's values are positive, and the input is targetSum","<","0, then you can return an empty list.",(0,i.mdx)("br",null)),(0,i.mdx)("h3",{id:"further-readings-3"},"Further Readings"),(0,i.mdx)("h3",{id:"solution-2"},"Solution"),(0,i.mdx)("h4",{id:"solution-using-recursion"},"Solution using Recursion"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        helper(result, new ArrayList<>(), root, targetSum);\n        return result;\n    }\n    private void helper(List<List<Integer>> result, List<Integer> list, TreeNode root, int targetSum) {\n        if(root == null) return;\n        list.add(root.val);\n        if(root.left == null && root.right == null && targetSum == root.val) {\n            result.add(new ArrayList<>(list));\n        }\n        helper(result, list, root.left, targetSum - root.val);\n        helper(result, list, root.right, targetSum - root.val);\n        list.remove(list.size() - 1);\n    }\n}\n")),(0,i.mdx)("h2",{id:"find-k-pairs-with-smallest-sums"},"Find K Pairs with Smallest Sums"),(0,i.mdx)("span",{class:"tag-is-success"},"Array"),(0,i.mdx)("span",{class:"tag-is-success"},"Heap (Priority Queue)"),(0,i.mdx)("h3",{id:"inputs-6"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        \n    }\n}\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\nInput: nums1 = [1,2], nums2 = [3], k = 3\nOutput: [[1,3],[2,3]]\nExplanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n")),(0,i.mdx)("h3",{id:"sub-problems-4"},"Sub-problems"),(0,i.mdx)("p",null,"\u2705 Using Priority Queue in such a manner that we don't have to produce nm(log(nm)) complexity solution.\n\u2705 Adding only k items into the pq at any point of time.\n\u2705 Which data-structure to use for storing the Pairs."),(0,i.mdx)("h3",{id:"edge-cases--clarifications"},"Edge Cases / Clarifications"),(0,i.mdx)("p",null,"\u2705 Checking if the input arrays are sorted.\n\u2705 If anyone of the inputs given are null/0. Then return an empty list."),(0,i.mdx)("h3",{id:"further-readings-4"},"Further Readings"),(0,i.mdx)("p",null,"\u2705 Adding items to Priority Queue with Custom Comparator.\n\u2705 Maintaining Priority Queue in a sorted manner and with Initial Capacity Constructor."),(0,i.mdx)("h3",{id:"solution-3"},"Solution"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        int n = nums1.length;\n        int m = nums2.length;\n        List<List<Integer>> ans = new ArrayList();\n        \n        if (n == 0 || m == 0) {\n            return ans;\n        }\n        \n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return (nums1[o1[0]] + nums2[o1[1]]) - (nums1[o2[0]] + nums2[o2[1]]);\n            }\n        });\n        \n        for (int i = 0; i < Math.min(k, n); i++) {\n            pq.add(new int[]{i, 0});\n        }\n\n        int size = pq.size();\n        \n        for (int i = 0; i < Math.min(k, n*m); i++) {\n            int[] pair = pq.remove();\n            \n            if (pair[1] < m - 1) {\n                pq.add(new int[]{pair[0], pair[1]+1});\n            }\n            \n            List<Integer> subsolution = new ArrayList();\n            subsolution.add(nums1[pair[0]]);\n            subsolution.add(nums2[pair[1]]);\n            ans.add(subsolution);\n        }\n        \n        return ans;\n    }\n}\n\n//Time Complexity: ~O(k*log(k))\n//Space Complexity: ~O(k)\n")),(0,i.mdx)("h2",{id:"lexicographical-numbers"},"Lexicographical Numbers"),(0,i.mdx)("span",{class:"tag-is-success"},"Depth-First Search"),(0,i.mdx)("span",{class:"tag-is-success"},"Trie"),(0,i.mdx)("h3",{id:"inputs-7"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<Integer> lexicalOrder(int n) {\n        \n    }\n}\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Input: n = 13\nOutput: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n\nInput: n = 2\nOutput: [1,2]\n\nConstraints:\n1 <= n <= 5 * 104\n")),(0,i.mdx)("h3",{id:"sub-problems-5"},"Sub-problems"),(0,i.mdx)("p",null,"\u2705 Using Priority Queue using Custom Comparator (on Strings) but the problem is that it will be O(nlog(n)) complexity.\n\u2705 How to compare the String respective of the Integer number.\n\u2705 Can we use DFS to iterate from 1->9, add the value and its corresponding 10th multiplier. Like 1, 10, 11, 12, 13, etc., which is i","*","10+i."),(0,i.mdx)("h3",{id:"edge-cases-6"},"Edge Cases"),(0,i.mdx)("p",null,"\u2705 If n is 0 or negative value. Then return an empty list.\n\u2705 If n is 1. Then return ","[1]","."),(0,i.mdx)("h3",{id:"further-readings-5"},"Further Readings"),(0,i.mdx)("p",null,"\u2705 Using Priority Queue with Custom Comparator.\n\u2705 Recursion and Sorting on the Collections."),(0,i.mdx)("h3",{id:"solution-4"},"Solution"),(0,i.mdx)("h4",{id:"using-dfs"},"Using DFS"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution {\n    public List<Integer> lexicalOrder(int n) {\n        List<Integer> res = new ArrayList<>();\n        for(int i=1;i<10;++i){\n          dfs(i, n, res); \n        }\n        return res;\n    }\n    \n    public void dfs(int cur, int n, List<Integer> res){\n        if(cur>n)\n            return;\n        else{\n            res.add(cur);\n            for(int i=0;i<10;++i){\n                if(10*cur+i>n)\n                    return;\n                dfs(10*cur+i, n, res);\n            }\n        }\n    }\n}\n\n// Time Complexity: O(n)\n// Space Complexity: O(1)\n")),(0,i.mdx)("h4",{id:"using-sort-on-list"},"Using Sort on List"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<Integer> lexicalOrder(int n) {\n        String[] strs = new String[n];\n        for(int i=1;i<=n;i++) strs[i-1] = Integer.toString(i);\n        Arrays.sort(strs);\n        List<Integer> op = new ArrayList<>();\n        for(String s: strs) op.add(Integer.parseInt(s));\n        return op;\n    }\n}\n\n//Time Complexity: O(nlog(n))\n//Space Complexity: O(n)\n")),(0,i.mdx)("h4",{id:"using-stack"},"Using Stack"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public List<Integer> lexicalOrder(int n) {\n        List<Integer> op = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n        for(int i=9;i>=1;i--) if(i<=n) stack.add(i);\n        while(stack.size()!=0){\n            int cur = stack.pop();\n            op.add(cur);\n            if(cur<n){\n                for(int i=9;i>=0;i--){\n                    int next = cur*10+i;\n                    if(next<=n) stack.add(next);\n                }\n            }\n        }\n        return op;\n    }\n}\n//Time Complexity: O(n)\n//Space Complexity: O(n)\n")),(0,i.mdx)("h2",{id:"rotate-function"},"Rotate Function"),(0,i.mdx)("span",{class:"tag-is-success"},"Array"),(0,i.mdx)("span",{class:"tag-is-success"},"Math"),(0,i.mdx)("span",{class:"tag-is-success"},"Dynamic Programming"),(0,i.mdx)("h3",{id:"inputs-8"},"Inputs"),(0,i.mdx)("h3",{id:"sub-problems-6"},"Sub-problems"),(0,i.mdx)("h3",{id:"edge-cases-7"},"Edge Cases"),(0,i.mdx)("h3",{id:"further-readings-6"},"Further Readings"),(0,i.mdx)("h2",{id:"valid-square"},"Valid Square"),(0,i.mdx)("span",{class:"tag-is-success"},"Math"),(0,i.mdx)("span",{class:"tag-is-success"},"Geometry"),(0,i.mdx)("h3",{id:"inputs-9"},"Inputs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        \n    }\n}\n")),(0,i.mdx)("h3",{id:"sub-problems-7"},"Sub-problems"),(0,i.mdx)("p",null,"\u2705 Calculating distance between two points.\n\u2705 Calculating slop from two points."),(0,i.mdx)("h4",{id:"properties-of-a-square"},"Properties of a Square"),(0,i.mdx)("p",null,"\u2705 All four sides should be of equal length. d=\u221a((x_2-x_1)\xb2+(y_2-y_1)\xb2)\n\u2705 Four 90-degree angles should be of equal length."),(0,i.mdx)("h3",{id:"edge-cases-8"},"Edge Cases"),(0,i.mdx)("p",null,"\u2705 If any of the points are the same, or the distance between any two points is zero, return false."),(0,i.mdx)("h3",{id:"solution-5"},"Solution"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution {\n    public double dist(int[] p1, int[] p2) {\n        // We are not using the square root as that is going to be same for all the points.\n        return (p2[1] - p1[1]) * (p2[1] - p1[1]) + (p2[0] - p1[0]) * (p2[0] - p1[0]);\n    }\n    public boolean check(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return dist(p1,p2) > 0 && dist(p1, p2) == dist(p2, p3) && dist(p2, p3) == dist(p3, p4) && dist(p3, p4) == dist(p4, p1) && dist(p1, p3) == dist(p2, p4);\n    }\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return check(p1, p2, p3, p4) || check(p1, p3, p2, p4) || check(p1, p2, p4, p3);\n    }\n}\n// Time complexity : O(1). A fixed number of comparisons are done.\n// Space complexity : O(1). No extra space required.\n")),(0,i.mdx)("h4",{id:"checkpoints"},"Checkpoints"),(0,i.mdx)("p",null,"\u2705 Check if any two points' distance is greater than 0.\n\u2705 Check if any two points' distance is equal to the distance between the other two points.\n\u2705 If any of the above scenerio fails to meet, return false."))}m.isMDXComponent=!0},7373:()=>{}}]);