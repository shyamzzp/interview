"use strict";(self.webpackChunkinterview=self.webpackChunkinterview||[]).push([[2875],{2289:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=n(7462),a=(n(7294),n(7373));const o={tree_title:"Depth First Search",description:"This will cover the most of the topics that will be part of the Depth First Search.",last_modified:new Date("2022-06-08T15:36:32.363Z")},s="DFS (Depth First Search)",l={unversionedId:"data-structures/dfs",id:"data-structures/dfs",title:"DFS (Depth First Search)",description:"This will cover the most of the topics that will be part of the Depth First Search.",source:"@site/docs/data-structures/dfs.md",sourceDirName:"data-structures",slug:"/data-structures/dfs",permalink:"/interview/docs/data-structures/dfs",draft:!1,tags:[],version:"current",frontMatter:{tree_title:"Depth First Search",description:"This will cover the most of the topics that will be part of the Depth First Search.",last_modified:"2022-06-08T15:36:32.363Z"},sidebar:"docs",previous:{title:"Deque (Doubly Ended Queue)",permalink:"/interview/docs/data-structures/dequeue"},next:{title:"Graph",permalink:"/interview/docs/data-structures/graph"}},i={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Implementation of DFS",id:"implementation-of-dfs",level:2},{value:"Using Stack",id:"using-stack",level:3},{value:"Using Recursion",id:"using-recursion",level:3},{value:"Common Problems (Frequently Asked Questions)",id:"common-problems-frequently-asked-questions",level:2},{value:"Binary Tree Paths",id:"binary-tree-paths",level:3},{value:"Path Sum",id:"path-sum",level:3},{value:"Same Tree",id:"same-tree",level:3}],d={toc:u};function h(e){let{components:t,...n}=e;return(0,a.mdx)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"dfs-depth-first-search"},"DFS (Depth First Search)"),(0,a.mdx)("h2",{id:"introduction"},"Introduction"),(0,a.mdx)("p",null,"\u27a1\ufe0f Depth\u2013first search (DFS) is an algorithm for traversing or searching tree or graph data structures.",(0,a.mdx)("br",null),"\n\u27a1\ufe0f One starts at the root (selecting some arbitrary node as the root for a graph) and explore as far as possible along each branch before backtracking.",(0,a.mdx)("br",null)),(0,a.mdx)("h2",{id:"implementation-of-dfs"},"Implementation of DFS"),(0,a.mdx)("p",null,"\u27a1\ufe0f Both the below implementations are same. ",(0,a.mdx)("br",null),"\n\u27a1\ufe0f The only difference is, the first one uses Stack which you can visualize better ",(0,a.mdx)("br",null)," and for the second case, how the internal stack is used. ",(0,a.mdx)("br",null),"\n\u27a1\ufe0f Both are the In-order Traversal of a Binary Tree.",(0,a.mdx)("br",null)),(0,a.mdx)("div",{class:"section-container pl0 pr0"},(0,a.mdx)("div",{class:"section-item pl0"},(0,a.mdx)("h3",{id:"using-stack"},"Using Stack"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-java"},"public class Solution{\n    public void dfs(Node root){\n        Stack<Node> stack = new Stack<>();\n        Node current = root;\n        while(current != null || !stack.isEmpty()){\n            if(current != null){\n                stack.push(current);\n                current = current.left;\n            }else{\n                current = stack.pop();\n                System.out.println(current.data);\n                current = current.right;\n            }\n        }\n    }\n}\n"))),(0,a.mdx)("div",{class:"section-item"},(0,a.mdx)("h3",{id:"using-recursion"},"Using Recursion"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-java"},"public class Solution{\n    public void dfs(Node root){\n        if(root == null) return;\n        dfs(root.left);\n        System.out.println(root.data);\n        dfs(root.right);\n        \n    }\n}\n")))),(0,a.mdx)("h2",{id:"common-problems-frequently-asked-questions"},"Common Problems (Frequently Asked Questions)"),(0,a.mdx)("h3",{id:"binary-tree-paths"},"Binary Tree Paths"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<List<Integer>> paths = new ArrayList<List<Integer>>();\n        // Edge case\n        if (root == null) {\n            return new ArrayList<String>();\n        }\n        List<Integer> path = new ArrayList<>();\n        dfsMethod1(root, path, paths);\n        // or\n        //dfsMethod2(root, path, paths);\n        System.out.println(paths);\n        return new ArrayList<String>();\n    }\n\n    private void dfsMethod1(TreeNode node,List<Integer> path,List<List<Integer>> paths) {\n        if (node == null) return;\n        path.add(node.val);\n        if (node.left == null && node.right == null) {\n            paths.add(new ArrayList<>(path));\n        }\n        dfs(node.left, path, paths);\n        dfs(node.right, path, paths);\n        path.remove(path.size() - 1);\n    }\n\n    //Alternative : You don't need to check the initial null condition, If all the recursive call\n    //are made only when the node's left and right is not null.\n    private void dfsMethod2(TreeNode node,List<Integer> path,List<List<Integer>> paths) {\n        path.add(node.val);\n        if (node.left == null && node.right == null) {\n            paths.add(new ArrayList<>(path));\n        }\n        if (node.left != null) {\n            dfs(node.left, path, paths);\n        }\n        if (node.right != null) {\n            dfs(node.right, path, paths);\n        }\n        path.remove(path.size() - 1);\n    }\n}\n")),(0,a.mdx)("h3",{id:"path-sum"},"Path Sum"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExplanation: The root-to-leaf path with the target sum is shown.\n\nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExplanation: There two root-to-leaf paths in the tree:\n(1 --\x3e 2): The sum is 3.\n(1 --\x3e 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\nInput: root = [], targetSum = 0\nOutput: false\nExplanation: Since the tree is empty, there are no root-to-leaf paths.\n")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    boolean flag = false;\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root == null ) return false;\n        if(targetSum-root.val == 0 && root.left == null && root.right == null) return true;\n        return helper(root.left, targetSum-root.val) || helper(root.right, targetSum-root.val);\n        \n    }\n    public boolean helper(TreeNode root, int sum){\n        if(root == null) return false;\n        if(sum-root.val == 0 && root.left == null && root.right == null) return true;\n        return helper(root.left, sum-root.val) || helper(root.right, sum-root.val);\n    }\n}\n")),(0,a.mdx)("h3",{id:"same-tree"},"Same Tree"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"Input: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null && q != null || (p != null && q == null)) return false;        \n        if(p.val == q.val) return true;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n")))}h.isMDXComponent=!0},7373:()=>{}}]);