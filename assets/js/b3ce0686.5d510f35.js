"use strict";(self.webpackChunkinterview=self.webpackChunkinterview||[]).push([[5064],{8377:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>d,toc:()=>m});var n=a(7462),i=(a(7294),a(7373));const r={tree_title:"Math",description:"This will cover the most of the topics that will be part of the Math.",last_modified:new Date("2022-06-08T16:35:30.353Z")},l="Math",d={unversionedId:"data-structures/math",id:"data-structures/math",title:"Math",description:"This will cover the most of the topics that will be part of the Math.",source:"@site/docs/data-structures/math.md",sourceDirName:"data-structures",slug:"/data-structures/math",permalink:"/interview/docs/data-structures/math",draft:!1,tags:[],version:"current",frontMatter:{tree_title:"Math",description:"This will cover the most of the topics that will be part of the Math.",last_modified:"2022-06-08T16:35:30.353Z"},sidebar:"docs",previous:{title:"Map",permalink:"/interview/docs/data-structures/map"},next:{title:"Matrix",permalink:"/interview/docs/data-structures/matrix"}},o={},m=[{value:"One Liner.",id:"one-liner",level:2},{value:"GCD/HCF - Euclidean Algorithm",id:"gcdhcf---euclidean-algorithm",level:2},{value:"Sieve of Eratosthenes",id:"sieve-of-eratosthenes",level:2},{value:"Modulo Exponentiation, Arithmetic and Inverse",id:"modulo-exponentiation-arithmetic-and-inverse",level:2},{value:"Logarithmic Bounds",id:"logarithmic-bounds",level:2},{value:"References",id:"references",level:2}],s={toc:m};function u(e){let{components:t,...r}=e;return(0,i.mdx)("wrapper",(0,n.Z)({},s,r,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"math"},"Math"),(0,i.mdx)("h2",{id:"one-liner"},"One Liner."),(0,i.mdx)("table",null,(0,i.mdx)("thead",{parentName:"table"},(0,i.mdx)("tr",{parentName:"thead"},(0,i.mdx)("th",{parentName:"tr",align:null},"Description"),(0,i.mdx)("th",{parentName:"tr",align:null},"Snippet"),(0,i.mdx)("th",{parentName:"tr",align:null},"Explaination"))),(0,i.mdx)("tbody",{parentName:"table"},(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},"To check if Double is an Integer"),(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("code",null,"if(d%1==0)")),(0,i.mdx)("td",{parentName:"tr",align:null},"if true then d is integer.")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},"To check power of any number"),(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("code",null,"double temp = Math.log(n)/Math.log(2);")),(0,i.mdx)("td",{parentName:"tr",align:null},"Resultant temp should be Integer.")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},"LCD of two numbers"),(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("code",null,"LCM(a, b) = (a x b) / GCD(a, b)")),(0,i.mdx)("td",{parentName:"tr",align:null},"Program for GCD is below.")))),(0,i.mdx)("h2",{id:"gcdhcf---euclidean-algorithm"},"GCD/HCF - Euclidean Algorithm"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public static int gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b%a, a);\n}\n// Time Complexity: O(Log min(a, b))  \n// Auxiliary Space: O(1)\n")),(0,i.mdx)("h2",{id:"sieve-of-eratosthenes"},"Sieve of Eratosthenes"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Generating primes fast is very important in some problems.You can use the Sieve of Eratosthenes to find all the prime numbers that are less than or equal to a given number N or to find out whether a number is a prime number. The basic idea behind the Sieve of Eratosthenes is that at each iteration one prime number is picked up and all its multiples are eliminated. After the elimination process is complete, all the unmarked numbers that remain are prime.\n\n")),(0,i.mdx)("h2",{id:"modulo-exponentiation-arithmetic-and-inverse"},"Modulo Exponentiation, Arithmetic and Inverse"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"1. (a+b)%c = (a%c+b%c)%c \n2. (a?b)%c = ((a%c)?(b%c))%c \n3. (a?b)%c = ((a%c)?(b%c)+c)%c \n4. (a/b)%c = ((a%c)?(b%c))%c \n\n")),(0,i.mdx)("h2",{id:"logarithmic-bounds"},"Logarithmic Bounds"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Input: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n")),(0,i.mdx)("p",null,(0,i.mdx)("img",{alt:"Logarithmic Bounds BorderRadius8",src:a(5206).Z,width:"607",height:"298"})),(0,i.mdx)("p",null,"\u27a1\ufe0f So basically we are trying to find x^a+y^b where a and b are termination condition for the nested loops."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"int a = x == 1 ? bound : (int) (Math.log(bound) / Math.log(x));\nint b = y == 1 ? bound : (int) (Math.log(bound) / Math.log(y));\n\nfor (int i = 0; i <= a; i++) {\n    for (int j = 0; j <= b; j++) {\n        //Code here to add the numbers to the Set.\n    }\n}\n")),(0,i.mdx)("p",null,(0,i.mdx)("img",{alt:"Complexity Analysis BorderRadius8",src:a(3236).Z,width:"602",height:"208"})),(0,i.mdx)("h2",{id:"references"},"References"),(0,i.mdx)("ul",null,(0,i.mdx)("li",null,(0,i.mdx)("a",{href:"https://leetcode.com/problems/powerful-integers/"},"Logarithmic Bounds"))))}u.isMDXComponent=!0},5206:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/2022-06-18-10-40-09-934bf3cdfe4ec9b6bf526c135a1f4531.png"},3236:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/2022-06-18-10-44-05-f0c2f0fa332259d920321fb6c3d84ce0.png"},7373:()=>{}}]);