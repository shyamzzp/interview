"use strict";(self.webpackChunkinterview=self.webpackChunkinterview||[]).push([[4064],{5162:(e,n,t)=>{t.d(n,{Z:()=>o});var a=t(7294),i=t(6010);const r="tabItem_Ymn6";function o(e){let{children:n,hidden:t,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,o),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>p});var a=t(7462),i=t(7294),r=t(6010),o=t(2389),l=t(7392),s=t(7094),m=t(2466);const u="tabList__CuJ",d="tabItem_LNqP";function c(e){var n,t;const{lazy:o,block:c,defaultValue:p,values:h,groupId:g,className:v}=e,x=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),b=null!=h?h:x.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),f=(0,l.l)(b,((e,n)=>e.value===n.value));if(f.length>0)throw new Error('Docusaurus error: Duplicate values "'+f.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const y=null===p?p:null!=(n=null!=p?p:null==(t=x.find((e=>e.props.default)))?void 0:t.props.value)?n:x[0].props.value;if(null!==y&&!b.some((e=>e.value===y)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+b.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:k,setTabGroupChoices:w}=(0,s.U)(),[N,S]=(0,i.useState)(y),E=[],{blockElementScrollPositionUntilNextRender:L}=(0,m.o5)();if(null!=g){const e=k[g];null!=e&&e!==N&&b.some((n=>n.value===e))&&S(e)}const A=e=>{const n=e.currentTarget,t=E.indexOf(n),a=b[t].value;a!==N&&(L(n),S(a),null!=g&&w(g,String(a)))},I=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{var a;const n=E.indexOf(e.currentTarget)+1;t=null!=(a=E[n])?a:E[0];break}case"ArrowLeft":{var i;const n=E.indexOf(e.currentTarget)-1;t=null!=(i=E[n])?i:E[E.length-1];break}}null==(n=t)||n.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",u)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":c},v)},b.map((e=>{let{value:n,label:t,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:N===n?0:-1,"aria-selected":N===n,key:n,ref:e=>E.push(e),onKeyDown:I,onFocus:A,onClick:A},o,{className:(0,r.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":N===n})}),null!=t?t:n)}))),o?(0,i.cloneElement)(x.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},x.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==N})))))}function p(e){const n=(0,o.Z)();return i.createElement(c,(0,a.Z)({key:String(n)},e))}},9570:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>m,toc:()=>d});var a=t(7462),i=(t(7294),t(7373)),r=t(5488),o=t(5162);const l={tree_title:"Algorithms",description:"This will cover the most of the topics that will be part of the Algorithms.",last_modified:new Date("2022-06-08T16:35:30.353Z")},s="Algorithms",m={unversionedId:"data-structures/algorithms",id:"data-structures/algorithms",title:"Algorithms",description:"This will cover the most of the topics that will be part of the Algorithms.",source:"@site/docs/data-structures/algorithms.md",sourceDirName:"data-structures",slug:"/data-structures/algorithms",permalink:"/interview/docs/data-structures/algorithms",draft:!1,tags:[],version:"current",frontMatter:{tree_title:"Algorithms",description:"This will cover the most of the topics that will be part of the Algorithms.",last_modified:"2022-06-08T16:35:30.353Z"},sidebar:"docs",previous:{title:"Data Structures",permalink:"/interview/docs/data-structures/"},next:{title:"Arrays",permalink:"/interview/docs/data-structures/arrays"}},u={},d=[{value:"0-1 Knapsack Problem",id:"0-1-knapsack-problem",level:2},{value:"Unbounded Knapsack (Repetition of items allowed)",id:"unbounded-knapsack-repetition-of-items-allowed",level:2},{value:"LRU Cache Implementation.",id:"lru-cache-implementation",level:2},{value:"Longest Common Subsequence.",id:"longest-common-subsequence",level:2},{value:"Merge K Sorted Linked List.",id:"merge-k-sorted-linked-list",level:2},{value:"Breadth-First Search (BFS) in 2D Matrix",id:"breadth-first-search-bfs-in-2d-matrix",level:2},{value:"Kadane\u2019s Algorithm (Largest Sum of Contiguous Subarray)",id:"kadanes-algorithm-largest-sum-of-contiguous-subarray",level:2},{value:"Boyer-Moore Voting Algorithm (Majority Element)",id:"boyer-moore-voting-algorithm-majority-element",level:2},{value:"Brian Kernighan\u2019s Algorithm (Count set bits in an integer)",id:"brian-kernighans-algorithm-count-set-bits-in-an-integer",level:2}],c={toc:d};function p(e){let{components:n,...l}=e;return(0,i.mdx)("wrapper",(0,a.Z)({},c,l,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"algorithms"},"Algorithms"),(0,i.mdx)("h2",{id:"0-1-knapsack-problem"},"0-1 Knapsack Problem"),(0,i.mdx)("div",{class:"section-container pl0 pr0"},(0,i.mdx)("div",{class:"section-item pl0"},(0,i.mdx)("p",null,(0,i.mdx)("img",{src:t(8574).Z,width:"507",height:"80"}))),(0,i.mdx)("div",{class:"section-item"},(0,i.mdx)("p",null,(0,i.mdx)("img",{src:t(672).Z,width:"540",height:"218"})))),(0,i.mdx)(r.Z,{mdxType:"Tabs"},(0,i.mdx)(o.Z,{value:"method-1",label:"Knapsack Recursive",mdxType:"TabItem"},(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class KnapsackRecursive {\n    static int knapSack(int W, int wt[], int val[], int n) {\n    // Base Case\n        if (n == 0 || W == 0) return 0;\n\n        // If weight of the nth item is\n        // more than Knapsack capacity W,\n        // then this item cannot be included\n        // in the optimal solution\n        if (wt[n - 1] > W) \n            return knapSack(W, wt, val, n - 1);\n        // Return the maximum of two cases:\n        // (1) nth item included\n        // (2) not included\n        else return Math.max(\n            val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1),\n            knapSack(W, wt, val, n - 1)\n        );\n    }\n}\n// Driver code\n// public static void main(String args[]) {\n//     int val[] = new int[] { 60, 100, 120 };\n//     int wt[] = new int[] { 10, 20, 30 };\n//     int W = 50;\n//     int n = val.length;\n//     System.out.println(knapSack(W, wt, val, n));\n// }\n"))),(0,i.mdx)(o.Z,{value:"method-2",label:"Knapsack Recursive + Memoization",mdxType:"TabItem"},(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class KnapsackRecursiveMemoization{\n    static int knapSackRec(int W, int wt[], int val[], int n, int[][] dp) {\n    // Base condition\n    if (n == 0 || W == 0) return 0;\n\n    if (dp[n][W] != -1) return dp[n][W];\n\n    if (wt[n - 1] > W) // Store the value of function call\n    // stack in table before return\n    return (\n        dp[n][W] = knapSackRec(W, wt, val, n - 1, dp)\n    ); else // Return value of table after storing\n    return (\n        dp[n][W] =\n        max(\n            (val[n - 1] + knapSackRec(W - wt[n - 1], wt, val, n - 1, dp)),\n            knapSackRec(W, wt, val, n - 1, dp)\n        )\n    );\n    }\n\n    static int knapSack(int W, int wt[], int val[], int N) {\n        int dp[][] = new int[N + 1][W + 1];\n        // Loop to initially filled the table with -1\n        for (int i = 0; i < N + 1; i++) for (int j = 0; j < W + 1; j++) dp[i][j] = -1;\n        return knapSackRec(W, wt, val, N, dp);\n    }\n}\n\n// Time Complexity: O(N*W). \n// Auxiliary Space: O(N*W).\n")))),(0,i.mdx)("h2",{id:"unbounded-knapsack-repetition-of-items-allowed"},"Unbounded Knapsack (Repetition of items allowed)"),(0,i.mdx)("p",null,"Given a knapsack weight W and a set of n items with certain value vali and weight wti, we need to calculate the maximum amount that could make up this quantity exactly.\nThis is different from classical Knapsack problem, here we are allowed to use unlimited number of instances of an item."),(0,i.mdx)(r.Z,{mdxType:"Tabs"},(0,i.mdx)(o.Z,{value:"method-1",label:"Unbounded Knapsack Recursive",mdxType:"TabItem"},(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"int unboundedKnapsack(int W, int wt[], int val[], int idx) {\n    // Base Case\n    // if we are at idx 0.\n    if (idx == 0) {\n        return (W / wt[0]) * val[0];\n    }\n    // There are two cases either take element or not\n    // take. If not take then\n    int notTake = 0 + unboundedKnapsack(W, wt, val, idx - 1);\n    // if take then weight = W-wt[idx] and index will\n    // remain same.\n    int take = Integer.MIN_VALUE;\n    if (wt[idx] <= W) {\n        take = val[idx] + unboundedKnapsack(W - wt[idx], wt, val, idx);\n    }\n    return max(take, notTake);\n}\n"))),(0,i.mdx)(o.Z,{value:"method-2",label:"Unbounded Knapsack Recursive + Memoization",mdxType:"TabItem"},(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class KnapsackDP {\n    private static int unboundedKnapsack(int W, int n, int[] val, int[] wt) {\n    // dp[i] is going to store maximum value\n    // with knapsack capacity i.\n    int dp[] = new int[W + 1];\n\n    // Fill dp[] using above recursive formula\n    for (int i = 0; i <= W; i++) {\n        for (int j = 0; j < n; j++) {\n            if (wt[j] <= i) {\n                dp[i] = max(dp[i], dp[i - wt[j]] + val[j]);\n            }\n        }\n    }\n    return dp[W];\n    }\n\n// Time Complexity: O(N*W). \n// Auxiliary Space: O(W).\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"\n// dp[i] = 0\n// dp[i] = max(dp[i], dp[i-wt[j]] + val[j] \n//                    where j varies from 0 \n//                    to n-1 such that:\n//                    wt[j] <= i\n// result = d[W]\n")))),(0,i.mdx)("h2",{id:"lru-cache-implementation"},"LRU Cache Implementation."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    int capacity;\n    Queue<Integer> q = new ArrayDeque<>();\n    Map<Integer, Integer> map = new LinkedHashMap<>();\n\n    public LRUCache(int capacity) {\n    this.capacity = capacity;\n    }\n\n    public int get(int key) {\n    if (map.containsKey(key)) {\n        q.remove(key); //O(n)\n        q.offer(key); //O(1)\n        return map.get(key); //O(1)\n    } else return -1;\n    }\n\n    public void put(int key, int value) {\n    if (map.containsKey(key)) {\n        q.remove(key); //O(n)\n        q.offer(key); //O(1)\n        map.put(key, value); //O(1)\n    } else {\n        if (q.size() < capacity) q.offer(key); else { //q.size() == capacity\n        map.remove(q.poll());\n        q.offer(key);\n        }\n        map.put(key, value);\n    }\n    }\n}\n")),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("em",{parentName:"p"},"Here are some additional properties and implementation methods :")),(0,i.mdx)("ul",{parentName:"blockquote"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("em",{parentName:"li"},"LRU cache is can also be implemented by\npairing a ",(0,i.mdx)("strong",{parentName:"em"},"doubly linked list")," with a ",(0,i.mdx)("strong",{parentName:"em"},"hash map"),".")),(0,i.mdx)("li",{parentName:"ul"},"Space Complexity : ",(0,i.mdx)("inlineCode",{parentName:"li"},"O(n)")),(0,i.mdx)("li",{parentName:"ul"},"Time Complexity :",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"get least recently used item")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"O(1)")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"access item")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"O(n)")))))),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'class LRUCache {\n    Set<Integer> cache;\n    int capacity;\n\n    public LRUCache(int capacity) {\n    this.cache = new LinkedHashSet<Integer>(capacity);\n    this.capacity = capacity;\n    }\n\n    public boolean get(int key) {\n    if (!cache.contains(key)) return false;\n    cache.remove(key);\n    cache.add(key);\n    return true;\n    }\n\n    public void put(int key) {\n    if (cache.size() == capacity) {\n        int firstKey = cache.iterator().next();\n        cache.remove(firstKey);\n    }\n    cache.add(key);\n    }\n\n    public void display() {\n    LinkedList<Integer> list = new LinkedList<>(cache);\n    Iterator<Integer> itr = list.descendingIterator();\n    while (itr.hasNext()) System.out.print(itr.next() + " ");\n    }\n}\n')),(0,i.mdx)("h2",{id:"longest-common-subsequence"},"Longest Common Subsequence."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'class Solution {\n\n    void lcs(String S1, String S2, int m, int n) {\n    int[][] LCS_table = new int[m + 1][n + 1];\n\n    // Building the mtrix in bottom-up way\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n        if (i == 0 || j == 0) LCS_table[i][j] = 0; else if (\n            S1.charAt(i - 1) == S2.charAt(j - 1)\n        ) LCS_table[i][j] = LCS_table[i - 1][j - 1] + 1; else LCS_table[i][j] =\n            Math.max(LCS_table[i - 1][j], LCS_table[i][j - 1]);\n        }\n    }\n        // If you just want to get the length of the longest \n        // subsequence you can return LCS_table[m][n];\n        // For printing the sequence.\n    int index = LCS_table[m][n];\n    int temp = index;\n\n    char[] lcs = new char[index + 1];\n    lcs[index] = \'\\0\';\n\n    int i = m, j = n;\n    while (i > 0 && j > 0) {\n        if (S1.charAt(i - 1) == S2.charAt(j - 1)) {\n        lcs[index - 1] = S1.charAt(i - 1);\n\n        i--;\n        j--;\n        index--;\n        } else if (LCS_table[i - 1][j] > LCS_table[i][j - 1]) i--; else j--;\n    }\n\n    // Printing the sub sequences\n    System.out.print("S1 : " + S1 + "\\nS2 : " + S2 + "\\nLCS: ");\n    for (int k = 0; k <= temp; k++) System.out.print(lcs[k]);\n    System.out.println("");\n    }\n}\n\n// Time Complexity : O(n*m)\n// Auxiliary Space : O(n*m + lengthOfLongestSequence)\n')),(0,i.mdx)("h2",{id:"merge-k-sorted-linked-list"},"Merge K Sorted Linked List."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"ListNode merge(ListNode[] heads) {\nListNode resultHead = null;\nListNode current = null;\n\nPriorityQueue<ListNode> pq = new PriorityQueue<>(\n    new Comparator<ListNode>() {\n\n    @Override\n    public int compare(ListNode o1, ListNode o2) {\n        return o1.data - o2.data;\n    }\n    }\n);\n\n//insert all heads into priority queue\nfor (int i = 0; i < heads.length; i++) {\n    if (heads[i] != null) {\n    pq.offer(heads[i]);\n    }\n}\n\nwhile (!pq.isEmpty()) {\n    //extract the min from priority queue\n    ListNode node = pq.poll();\n\n    //add it to result Head\n    if (resultHead == null) {\n    resultHead = node;\n    current = node;\n    } else {\n    current.next = node;\n    current = current.next;\n    }\n\n    //add next List Node to priority queue\n    if (node.next != null) {\n    pq.add(node.next);\n    }\n}\nreturn resultHead;\n}\n")),(0,i.mdx)("h2",{id:"breadth-first-search-bfs-in-2d-matrix"},"Breadth-First Search (BFS) in 2D Matrix"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'class Solution {\n\n  public void BFS(int[][] grid) {\n    int h = grid.length;\n    if (h == 0) return;\n    int l = grid[0].length;\n\n    boolean[][] visited = new boolean[h][l];\n\n    Queue<String> queue = new LinkedList<>();\n\n    queue.add(0 + "," + 0);\n\n    System.out.println("Breadth-First Traversal: ");\n    while (queue.isEmpty() == false) {\n      String x = queue.remove();\n      int row = Integer.parseInt(x.split(",")[0]);\n      int col = Integer.parseInt(x.split(",")[1]);\n\n      if (\n        row < 0 || col < 0 || row >= h || col >= l || visited[row][col]\n      ) continue;\n\n      visited[row][col] = true;\n      System.out.print(grid[row][col] + " ");\n      queue.add(row + "," + (col - 1)); //go left\n      queue.add(row + "," + (col + 1)); //go right\n      queue.add((row - 1) + "," + col); //go up\n      queue.add((row + 1) + "," + col); //go down\n    }\n  }\n}\n\n')),(0,i.mdx)("h2",{id:"kadanes-algorithm-largest-sum-of-contiguous-subarray"},"Kadane\u2019s Algorithm (Largest Sum of Contiguous Subarray)"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class KadaneAlgo{\n    int maxSubArraySum(int a[]) {\n    int max_so_far = a[0], max_ending_here = a[0];\n\n    for (int i = 0; i < a.length; i++) {\n        max_ending_here = max_ending_here + a[i];\n        max_so_far = Math.max(max_so_far,max_ending_here);\n        if (max_ending_here < 0) max_ending_here = 0;\n    }\n    return max_so_far;\n    }\n}\n")),(0,i.mdx)("h2",{id:"boyer-moore-voting-algorithm-majority-element"},"Boyer-Moore Voting Algorithm (Majority Element)"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    public int majorityElement(int[] nums) {\n        int count = 0;\n        Integer candidate = null;\n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            count += (num == candidate) ? 1 : -1;\n        }\n        return candidate;\n    }\n}\n// Time complexity : O(n)\n// Space complexity : O(1)\n")),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("em",{parentName:"p"},"The\xa0",(0,i.mdx)("strong",{parentName:"em"},"Boyer-Moore voting")," algorithm is one of the popular optimal\nalgorithms which is used to find the majority element among the\ngiven elements that have more than N/ 2 occurrences. This works\nperfectly fine for finding the majority element which takes 2 traversals\nover the given elements, which works in O(N) time complexity\nand O(1) space complexity."),"\n",(0,i.mdx)("em",{parentName:"p"},"Returns you the majority candidate not the\nactual count of the element. For that you\nhave to use another algorithm."))),(0,i.mdx)("h2",{id:"brian-kernighans-algorithm-count-set-bits-in-an-integer"},"Brian Kernighan\u2019s Algorithm (Count set bits in an integer)"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"class Solution {\n    int countSetBits(int n) {\n        int count = 0;\n        while (n > 0) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n}\n// Time complexity : O(log n)\n// Space complexity : O(1)\n")),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("em",{parentName:"p"},"The\xa0",(0,i.mdx)("strong",{parentName:"em"},"Boyer-Moore voting")," algorithm is one of the popular optimal\nalgorithms which is used to find the majority element among the\ngiven elements that have more than N/ 2 occurrences. This works\nperfectly fine for finding the majority element which takes 2 traversals\nover the given elements, which works in O(N) time complexity\nand O(1) space complexity."))),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("em",{parentName:"p"},"Returns you the majority candidate not the\nactual count of the element. For that you\nhave to use another algorithm."))))}p.isMDXComponent=!0},672:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/2022-06-29-23-53-17-2025bb6a06698822e9a0c9f0f5d3a67e.png"},8574:(e,n,t)=>{t.d(n,{Z:()=>a});const a="data:image/png;base64,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"},7373:()=>{}}]);